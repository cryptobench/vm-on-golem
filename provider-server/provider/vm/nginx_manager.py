import os
import logging
import subprocess
from pathlib import Path
from typing import Optional
from datetime import datetime

from .port_manager import PortManager

logger = logging.getLogger(__name__)

class NginxConfigError(Exception):
    """Raised when nginx configuration operations fail."""
    pass

class NginxManager:
    """Manages nginx configuration for VM SSH proxying."""
    
    CONFIG_TEMPLATE = """# Auto-generated by Golem Provider at {timestamp}
# VM: {vm_id}
upstream vm_{vm_id} {{
    server {vm_ip}:22;
}}

server {{
    listen {port};
    proxy_connect_timeout 1s;
    proxy_timeout 24h;  # SSH needs long timeouts
    proxy_pass vm_{vm_id};
}}
"""
    
    def __init__(
        self,
        nginx_dir: str = "/opt/homebrew/etc/nginx",
        config_dir: Optional[str] = None,
        port_manager: Optional[PortManager] = None
    ):
        """Initialize the nginx manager.
        
        Args:
            nginx_dir: Base nginx installation directory
            config_dir: Directory for VM-specific configs
            port_manager: Port allocation manager
        """
        self.nginx_dir = nginx_dir
        self.config_dir = config_dir or os.path.join(nginx_dir, "golem.d")
        self.port_manager = port_manager or PortManager()
        
        # Ensure config directory exists with proper permissions
        try:
            if not os.path.exists(self.config_dir):
                subprocess.run(
                    ["sudo", "mkdir", "-p", self.config_dir],
                    check=True,
                    capture_output=True
                )
                subprocess.run(
                    ["sudo", "chown", "-R", f"{os.getuid()}:{os.getgid()}", self.config_dir],
                    check=True,
                    capture_output=True
                )
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to create config directory: {e.stderr}")
            raise NginxConfigError("Failed to initialize nginx configuration directory")
        
        # Create/update main config include
        self._ensure_main_config()
    
    def _ensure_main_config(self) -> None:
        """Ensure main nginx.conf includes our config directory."""
        main_conf = os.path.join(self.nginx_dir, "nginx.conf")
        
        try:
            with open(main_conf, 'r') as f:
                content = f.read()
            
            # Check if our include is already present
            include_line = f'include {self.config_dir}/*.conf;'
            if include_line not in content:
                # Add include at the end of the stream block
                if 'stream {' in content:
                    # Find the end of the stream block
                    stream_end = content.find('}', content.find('stream {'))
                    if stream_end != -1:
                        # Insert before the closing brace
                        content = content[:stream_end] + f'    {include_line}\n' + content[stream_end:]
                        subprocess.run(
                            ["sudo", "tee", main_conf],
                            input=content.encode(),
                            check=True,
                            capture_output=True
                        )
                        logger.info(f"Added Golem config include to {main_conf}")
        except Exception as e:
            raise NginxConfigError(f"Failed to update main nginx config: {e}")
    
    def _get_config_path(self, vm_id: str) -> str:
        """Get path for VM-specific config file."""
        return os.path.join(self.config_dir, f"vm_{vm_id}.conf")
    
    def _test_config(self) -> bool:
        """Test nginx configuration."""
        try:
            subprocess.run(
                ["sudo", "nginx", "-t"],
                check=True,
                capture_output=True,
                text=True
            )
            return True
        except subprocess.CalledProcessError as e:
            logger.error(f"Nginx config test failed: {e.stderr}")
            return False
    
    def _reload_nginx(self) -> None:
        """Reload nginx configuration."""
        try:
            subprocess.run(
                ["sudo", "brew", "services", "restart", "nginx"],
                check=True,
                capture_output=True,
                text=True
            )
            logger.info("Nginx configuration reloaded")
        except subprocess.CalledProcessError as e:
            raise NginxConfigError(f"Failed to reload nginx: {e.stderr}")
    
    def add_vm(self, vm_id: str, vm_ip: str) -> Optional[int]:
        """Add nginx configuration for a new VM.
        
        Args:
            vm_id: Unique identifier for the VM
            vm_ip: IP address of the VM
            
        Returns:
            Allocated port number or None if configuration failed
        """
        # Allocate port
        port = self.port_manager.allocate_port(vm_id)
        if port is None:
            logger.error(f"Failed to allocate port for VM {vm_id}")
            return None
        
        try:
            # Generate config
            config = self.CONFIG_TEMPLATE.format(
                timestamp=datetime.now().isoformat(),
                vm_id=vm_id,
                vm_ip=vm_ip,
                port=port
            )
            
            # Write config file using sudo
            config_path = self._get_config_path(vm_id)
            subprocess.run(
                ["sudo", "tee", config_path],
                input=config.encode(),
                check=True,
                capture_output=True
            )
            
            # Test and reload
            if not self._test_config():
                # Cleanup on failure
                subprocess.run(["sudo", "rm", "-f", config_path], check=True)
                self.port_manager.deallocate_port(vm_id)
                return None
            
            self._reload_nginx()
            return port
            
        except Exception as e:
            logger.error(f"Failed to configure nginx for VM {vm_id}: {e}")
            self.port_manager.deallocate_port(vm_id)
            return None
    
    def remove_vm(self, vm_id: str) -> None:
        """Remove nginx configuration for a VM.
        
        Args:
            vm_id: Unique identifier for the VM
        """
        config_path = self._get_config_path(vm_id)
        
        try:
            if os.path.exists(config_path):
                subprocess.run(["sudo", "rm", "-f", config_path], check=True)
                self._reload_nginx()
            
            self.port_manager.deallocate_port(vm_id)
            logger.info(f"Removed nginx config for VM {vm_id}")
            
        except Exception as e:
            logger.error(f"Failed to remove nginx config for VM {vm_id}: {e}")
    
    def get_port(self, vm_id: str) -> Optional[int]:
        """Get allocated port for a VM."""
        return self.port_manager.get_port(vm_id)

    def cleanup(self) -> None:
        """Remove all VM configurations."""
        try:
            for config in Path(self.config_dir).glob("vm_*.conf"):
                subprocess.run(["sudo", "rm", "-f", str(config)], check=True)
            
            self._reload_nginx()
            self.port_manager.cleanup()
            logger.info("Cleaned up all VM nginx configurations")
            
        except Exception as e:
            logger.error(f"Failed to cleanup nginx configs: {e}")
